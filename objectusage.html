<!doctype html>
<html lang="en">
    <head>
        <!-- 
        This page uses the Reveal.js presentation framework
        To find out more about reveal, visit http://lab.hakim.se/reveal-js/
        or https://github.com/hakimel/reveal.js
        -->
        <title>Digital Games - Using Objects</title>
        <meta name="description" content="IAT 167 - Digital Games - Using Objects">
        <meta charset="utf-8">
        <meta name="apple-mobile-web-app-capable" content="yes" />
        <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />
        <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
        <meta name="author" content="Matt Lockyer">
        <link rel="stylesheet" href="css/reveal.min.css">
        <link rel="stylesheet" href="css/theme/sky.css" id="theme">
        <link rel="stylesheet" href="css/main.css" id="theme">
        <!-- If the query includes 'print-pdf', use the PDF print sheet -->
        <script>
            document.write('<link rel="stylesheet" href="css/print/' + (window.location.search.match(/print-pdf/gi) ? 'pdf' : 'paper') + '.css" type="text/css" media="print">');
        </script>
        <!-- - [if lt IE 9]>
        <script src="lib/js/html5shiv.js"></script>
        <! - [endif]-->
    </head>
    <body>
        <a class="backlink" href="index.html#/1">Back</a>
        <div class="reveal">
            <div class="slides">


                <section>
                    <h3>Using Objects</h3>
                    <ul class="list-style-none">
                        <li><a href="#/1">Creating an Instance</a></li>
                        <li><a href="#/2">Arrays of Objects</a></li>
                        <li><a href="#/3">ArrayLists of Objects</a></li>
                        <li><a href="#/4">Typed ArrayLists</a></li>
                        <li><a href="#/5">Example</a></li>
                    </ul>
                    <h3>Reading</h3>
                    <ul class="list-style-none">
                        <li><a href="http://processing.org/learning/objects/">Learning Objects</a> (required)</li>
                        <li><a href="http://www.learningprocessing.com/" target="_blank">Learning Processing:</a> Chapter 8 (recommended)</li>
                    </ul>
                    <blockquote>
                        A poet is a professional maker of verbal objects. [W.H. Auden]
                    </blockquote>

                </section>
                <section>
                    <section>
                        <h3>Creating an Instance</h3>
                        <p>
                            Once an object is defined by a class definition, it can be instantiated, bringing an instance of that object into
                            your program, allowing you to change fields and call methods for that object.
                            Why is it important that we encapsulate information
                            inside an object and work with instances of objects rather than working with the data directly?
                            We do this to make our code both formally and conceptually cleaner. Remember working with strings? We
                            never had to know the details of the methods of the string class, or how they worked, we leveraged code that was
                            already written. This is the power of object oriented programming.
                        </p>

                    </section>
                    <section>
                        <h3>Example</h3>
                        <p class="code">PinkElephant myPet;</p>
                        declare a reference variable of type PinkElephant
                        <p class="code">myPet = new PinkElephant();</p>
                        create a new instance of PinkElephant, <br/>
                        assign it to the reference variable myPet
                        <h3>Calling the Constructor using "new"</h3>
                        <ul>
                            <li>Creates a new instance of the PinkElephant class by calling the constructor in the PinkElephant class.</li>
                            <li>A reference to the newly created object is returned to where the constructor was called using the new keyword.</li>
                            <li>The reference of the newly created object is assigned to the myPet reference variable.</li>
                        </ul>

                    </section>
                    <section>
                        <p>
                            Now that we have a reference variable of the type PinkElephant, we can go ahead and change some of this objects fields
                            or call some of it's methods.
                        </p>
                        <p>
                            <span class="code">myPet.size = 50;</span> set the size of myPet (a PinkElephant) to 50<br />
                            <span class="code">myPet.eatPeanuts();</span> tell the myPet object to eatPeanuts();<br />
                        </p>

                    </section>
                    <section>

                        <div class="important">When you create an instance of a class (an object) using the new keyword, you are actually
                            calling the constructor method of that class, which will return a reference to the newly created object.</div>
                        <div class="important">Make sure you declare a reference variable of the right type (class name) before you 
                            create a new instance of that object.</div>

                    </section>
                </section>
                <section>
                    <section>

                        <h3>Array of Objects</h3>

                        <p>
                            We've seen before that creating multiple elements of the same type can be tedious and time consuming in code.
                            It's much better to store similar primatives or complex (object) types in an array that can be controlled by a
                            loop. Here's how to declare an array of objects:
                        </p>
                        <p>
                            <span class="code">PinkElephant[] myPets;</span><br />
                            Declare an array of PinkElephant objects.<br />
                            <span class="code">myPets = new PinkElephant[5];</span><br />
                            Initialize the array of PinkElephant objects.<br />
                            NOTE: No instances of PinkElephant have been created yet...<br />
                            Only the array has been initialized, however each position is still empty (NO PINK ELEPHANTS)
                        </p>

                    </section>
                    <section>
                        <p>
                            Now let's initialize each position in our array with a new instance of the PinkElephant class:
                        </p>
                        <div class="codetabs" data-name="arrays" data-processing="js/local/processing.min.js"
                             data-width="900" data-height="200" data-noplay="true" data-nofullscreen="true" data-nozip="true" data-fontsize="16px" data-lines="#eee">
                            <textarea data-name="arrays.pde">
for (int i = 0; i < myPets.length; i++) {
    myPets[i] = new PinkElephant();
}</textarea></div>


                    </section>
                    <section>

                        <p>
                            Now what if we wanted to draw each of our "pets" of the type PinkElephant. Well first we would
                            want to make sure the PinkElephant class has a draw method. For the purposes of this demonstration let's assume it does.
                        </p>
                        <div class="codetabs" data-name="arrays" data-processing="js/local/processing.min.js"
                             data-width="900" data-height="200" data-noplay="true" data-nofullscreen="true" data-nozip="true" data-fontsize="16px" data-lines="#eee">
                            <textarea data-name="arrays.pde">
for (int i = 0; i < myPets.length; i++) {
    myPets[i].draw();
}</textarea></div>

                    </section>
                    <section>
                        <p>
                            So we've successfully called the draw method of each of our pets.
                        </p>

                        <div class="important">When we declare and initialize an Array of objects, the Array is empty.
                            it has a size, but doesn't contain any objects.</div>
                        <div class="important">Not until we've initialize each position in the array can we say that our array contains objects.</div>
                        <div class="important">Once each position in the array has be initialized with a new instance of the object class, we can
                            begin using those newly created objects in other portions of our sketch.</div>

                    </section>
                </section>
                <section>
                    <section>

                        <h3>ArrayList of Objects</h3>

                        <p>
                            Now we will go into the details of creating an ArrayList of objects. For some purposes an ArrayList is better
                            than an Array. Mainly if the size of your list is going to expand and contract, an Array won't be suited for this.
                            ArrayLists have the added benefit of not having a fixed size, which allows you to add and remove items when you wish.
                        </p>
                        <p>
                            <span class="code">ArrayList myPets;</span><br />
                            Declare an ArrayList.<br />
                            <span class="code">myPets = new ArrayList();</span><br />
                            Initialize the ArrayList.<br />
                            NOTE: ArrayLists are type agnostic by default (they do not know what kind of objects they contain)<br />
                        </p>


                    </section>
                    <section>
                        <p>
                            Now let's add some new instances of the PinkElephant class to our ArrayList:
                        </p>
                        <div class="codetabs" data-name="arrays" data-processing="js/local/processing.min.js"
                             data-width="900" data-height="200" data-noplay="true" data-nofullscreen="true" data-nozip="true" data-fontsize="16px" data-lines="#eee">
                            <textarea data-name="arrays.pde">
for (int i = 0; i < 5; i++) {
    myPets.add ( new PinkElephant() );
}</textarea></div>
                        <p>
                            Notice the use of the add( *object instance* ) method of the ArrayList. The ArrayList itself is an 
                            object, and add(...) is merely a method of the ArrayList class.<br />
                            Also note that when creating the ArrayList we never specified a size, so in our first for loop, we
                            cannot use the ArrayList method size() yet, since the ArrayList myPets contains no objects before
                            the loop.                            
                        </p>

                    </section>
                    <section>

                        <p>
                            Let's draw our PinkElephants inside the ArrayList myPets.                           
                        </p>
                        <div class="codetabs" data-name="arrays" data-processing="js/local/processing.min.js"
                             data-width="900" data-height="200" data-noplay="true" data-nofullscreen="true" data-nozip="true" data-fontsize="16px" data-lines="#eee">
                            <textarea data-name="arrays.pde">
for (int i = 0; i < myPets.size(); i++) {
    PinkElephant pinkE = (PinkElephant) myPets.get(i);
    pinkE.draw();
}</textarea></div>
                        <p>
                            Notice how we declared a new reference variable to store each reference we took out of our 
                            ArrayList using the get(index) method? This is merely a formality, and helps for calling other
                            methods of each object in the ArrayList.<br /> 
                        </p>

                    </section>
                    <section>
                        <p>
                            Since ArrayLists are type agnostic, the ArrayList does not remember that we added PinkElephant
                            objects into it. So when we use the get(index) method of the ArrayList it returns a reference
                            to an object of the generic type Object, not PinkElephant.
                        </p>
                        <p>
                            In order to use the reference variable returned by the get(index) method as a PinkElephant, we
                            must first cast it as such using the cast (PinkElephant).<br /> 
                        </p>

                    </section>
                </section>
                <section>
                    <section>

                        <h3>Typed ArrayList</h3>

                        <p>
                            We can declare a typed ArrayList which will behave a lot more like an Array since the ArrayList will
                            return references of the type we specify. Here is an example:
                        </p>

                        <div class="codetabs" data-name="arrays" data-processing="js/local/processing.min.js"
                             data-width="900" data-height="200" data-noplay="true" data-nofullscreen="true" data-nozip="true" data-fontsize="16px" data-lines="#eee">
                            <textarea data-name="arrays.pde">
ArrayList<PinkElephant> myPets = new ArrayList<PinkElephant>();
myPets.add( new PinkElephant() );
myPets.get(0).draw();</textarea></div>


                                        </section>
                                        <section>
                                            <p>
                                                This last line where we get and use the object instance directly as if it was an object of PinkElephant
                                                only works because our ArrayList is typed. This is an extremely useful feature of ArrayLists.
                                            </p>


                                            <div class="important">A newly created ArrayList has a size of 0.</div>
                                            <div class="important">ArrayLists do not remember the type of objects they contain, so each object reference
                                                obtained using the .get(index) method must be cast before using.</div>
                                            <div class="important">A typed ArrayList will always return a reference of the type specified when
                                                the ArrayList was created, making life much more simple.</div>

                                        </section>
                                        </section>

                                        <section id="sketch-parent">
                                            <div class="codetabs" data-name="sketch" data-processing="js/local/processing.min.js"
                                                 data-appendbody="true" data-width="800" data-height="550" data-ishidden="true" data-fontsize="16px" data-lines="#eee">
                                                <textarea data-name="sketch.pde">
//TYPED ARRAYLIST, WOO HOO!
ArrayList<Particle> particles = new ArrayList<Particle>();

//a class to describe a particle
class Particle {
  
  //fields
  float xPos, yPos, xVel, yVel;
  //a constructor to initialize the fields above with initial values
  Particle(float xPos, float yPos, float xVel, float yVel) {
    this.xPos = xPos; 
    this.yPos = yPos; 
    this.xVel = xVel; 
    this.yVel = yVel;
  }
  
  //update the state of this particle (movement and collision with walls)
  void update() {
    //update position
    xPos += xVel;
    yPos += yVel;
    //check walls
    if (abs(xPos - width/2) > width/2 - 16) {
      xVel *= -1;
    }
    if (abs(yPos - height/2) > height/2 - 16) {
      yVel *= -1;
    }
  }
  
  //draw the particle
  void draw() {
    pushMatrix();
    translate(xPos, yPos);
    ellipse(0, 0, 32, 32);
    popMatrix();
  }
  
}//Particle class

void setup() {
  size(fullWidth, fullHeight);
  stroke(0, 128);
  strokeWeight(2);
  fill(255, 0, 0, 128);
  //the ArrayList doesn't have a size yet
  //so we have to set how much we will loop literally
  for (int i = 0; i < 100; i++) {
    //make a new Particle object, assign to ref. var. newParticle
    Particle newParticle = new Particle(
    //arguments passed to the constructor set the initial values for a Particle object's fields
    //take a look at the parameters for the constructor in the Particle class
    random(16, width - 16), 
    random(16, height - 16), 
    random(-4, 4), 
    random(-4, 4)
      //end of arguments
    );
    //add the newParticle object to the ArrayList particles
    particles.add(newParticle);
  }
}

void draw() {
  background(255);
  //loop over all elements in the particles ArrayList, 0 - (particles.size() - 1)
  for (int i = 0; i < particles.size(); i++) {
    //get the current ball in the loop, the ball at position i
    //notice how we cast it as type Particle
    //this is so we can have access to the Particle variables (xPos, yPos, ...)
    //TYPED ARRAYLIST (CHECK DECLARACTION AT TOP)
    //NO NEED TO CAST OBJECT TO PARTICLE TYPE!
    Particle curParticle = particles.get(i);
    //call the update method of the Particle class
    curParticle.update();
    //call the draw method of the Particle class
    curParticle.draw();
  }
}
                                                </textarea>
                                            </div>
                                        </section>

                                        </div>
                                        </div>



                                        <script src="lib/js/head.min.js"></script>
                                        <script src="js/reveal.min.js"></script>
                                        <script src="js/codetabs.js"></script>
                                        <script type="text/javascript">
            Reveal.addEventListener('ready', function() {
                setTimeout(checkSketches, 1500);
            });
            Reveal.addEventListener('overviewshown', checkSketches);
            Reveal.addEventListener('overviewhidden', checkSketches);
            Reveal.addEventListener('slidechanged', checkSketches);
            function checkSketches() {
                var slide = Reveal.getCurrentSlide();
                var sketch = document.getElementById('sketch');
                if (sketch) {
                    sketch.hide();
                    if (!Reveal.isOverview() && slide === document.getElementById('sketch-parent')) {
                        sketch.fadeIn();
                        document.getElementsByClassName('slides')[0].style.display = 'none';
                    } else {
                        document.getElementsByClassName('slides')[0].style.display = 'block';
                        Reveal.layout();
                    }
                }
            }
                                        </script>
                                        <script>
                                            // Full list of configuration options available here:
                                            // https://github.com/hakimel/reveal.js#configuration
                                            Reveal.initialize({
                                                width: 1024,
                                                height: 768,
                                                margin: 0.06,
                                                controls: true,
                                                progress: true,
                                                history: true,
                                                center: true,
                                                theme: Reveal.getQueryHash().theme, // available themes are in /css/theme
                                                transition: Reveal.getQueryHash().transition || 'default', // default/cube/page/concave/zoom/linear/fade/none

                                                // Optional libraries used to extend on reveal.js
                                                dependencies: -[
                                                    {src: 'lib/js/classList.js', condition: function() {
                                                            return !document.body.classList;
                                                        }},
                                                    {src: 'plugin/zoom-js/zoom.js', async: true, condition: function() {
                                                            return !!document.body.classList;
                                                        }},
                                                    {src: 'plugin/notes/notes.js', async: true, condition: function() {
                                                            return !!document.body.classList;
                                                        }}
                                                ]
                                            });
                                        </script>
                                        </body>
                                        </html>
